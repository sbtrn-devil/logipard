#LP-include lp-module-inc.lp-txt
#-LP (Note: in lp-txt, LP-include tag should be followed by #-LP or #LP:, as there is no way to break contiguity of tag block in the plain-text mode.)

#LP: <#./%title: Logipard#>
Logipard (LP for short) is a documentation generator with emphasis on freeform documentation model and customization-driven pipeline.

#LP M/concepts: <#./%title: Main Concepts#>

Now we can describe ideas and concepts of Logipard in more detail.

First of all, you should get acquainted with <#ref M/model#>, as it is the comprehension of the documentation you will be working in, and it pervades Logipard pipeline in every aspect, from
annotations in the documented source code to interface of Logipard customization toolkits.

Speaking of the pipeline, Logipard's documentation generation process is organized like this:

<#img logipard-pipeline-c.png#>

As it shows, the pipeline assumes user customization at all of the key points. Although Logipard comes with some built-ins to get started, and you don't have to delve into it right away,
be aware that the possibilities are much wider.

Get to know more about each pipeline stage: <#ref M/stages#>

All details of the pipeline within the project are specified by Logipard configuration file - get to know about it in specific details: <#ref M/lp-config.json#>

After you are familiar enough with all these subjects (and the dependent subjects within), the reference on all the user facing items and interfaces can be found here: <#ref M/reference#>

#LP M/stages { <#./%title: Logipard Pipeline Stages#>
Logipard documentation generation occurs in three stages:
- _extraction_ of annotations into uniform input files understood by the FDOM compiler
- _compilation_ from input files into actual FDOM
- _generation_ of whatever documentation artifacts are needed based on the compiled FDOM

When you invoke Logipard CLI, it runs all of the stages in the order listed above. Each stage relies on artifacts generated by the previous one, but, as these artifacts are generally retained,
you may only (re-)run some stages by explicitly specifying the ones you need.

Run extraction stage only:
```
lp-cli --extract <config-file>
```

Run compilation stage only:
```
lp-cli --compile <config-file>
```

Run generation stage only:
```
lp-cli --generate <config-file>
```

Run compilation and generation stage:
```
lp-cli --compile --generate <config-file>
```

...etc.

#LP M/stages/extract-stage { <#./%title: Extraction stage#>
At this stage the documentation annotations are extracted from the source files (or other types of sources) and put into __Logipard input files__ of a certain uniformed format.
This job is done by plugins named __extraction readers__.

Although the expected format of this stage's output (and input for the compilation stage) is fixed, the annotations format itself, as well as their decoding, is up to the extraction readers.
It is possible for example to make a reader from javadoc or doxygen comments, machine-readable output of some compiler, or even from the code itself. It is also an option to pass the same sources
through several extractors, letting each one to extract its own recognized part of the input.

Although it is technically possible to extract inputs for several independent FDOMs, in general it is expected that all extractors of a project will prepare input for the same single FDOM,
and that they will follow some consistent common convention when organizing the extracted input files. For handling independent FDOMs, a better practice is to have separate project configuration files.

Extraction stage is controlled by <#ref M/lp-config.json/members/lp-extract#> entry of the configuration file.

Extraction reader must be implemented in compliance with the corresponding interface: <#ref M/interfaces/extract/reader#>.

Logipard comes with some built-in extraction readers: <#ref M/stages/extract-stage/builtin-readers#>

#LP }

#LP M/stages/compile-stage { <#./%title: Compilation stage#>
At this stage, the extracted input will be compiled into an actual FDOM representation.
Logipard does not enforce specific FDOM representation and storage mechanism. Instead, it feeds the model creation and update commands to the plugins named __compiled model writers__, and it is up to them how
to represent and actually store the model - in a local file of certain format, in a DB backend, or using some online service. Complementary to them, there is also notion of __compiled model readers__, which
are assumed to read the FDOM from the storage created/updated by matching compiled model writers and to expose it for querying by a user (typically by a generator at the generation stage).

Compilation stage is controlled by <#ref M/lp-config.json/members/lp-compile#> entry of the configuration file.

Compiled model writer must be implemented in compliance with the corresponding interface: <#ref M/interfaces/compile/writer#>.

Compiled model reader implementation is up to the customizer, although it is recommended to align with FDOM querying concept: <#ref M/model/querying#>.

Logipard comes with some built-in compiled model writers: <#ref M/stages/compile-stage/builtin-writers#>
and corresponding model readers: <#ref M/stages/compile-stage/builtin-readers#>

#LP ./builtin-readers { <#./%title: Built-in compiled model readers#>

The compiled model readers corresponding to the built-in compiled model writers.

#LP }

#LP }

#LP M/stages/generate-stage { <#./%title: Generation stage#>
At this stage, the final artifacts is expected to be produced from the compiled and stored FDOM. This job is delegated to plugins named __generation writers__ (or, in more general scope, simply __generators__).
A generator can do things only limited to user's resourcefulness. Most typically we would expect production of some end-user documentation item, but it can as well be an update in a wiki or an issue tracker,
or some code or config generation for a deliverable, or an intermediate artifact for next stage of some greater process spanning beyond Logipard.

Since job items of the stage are ordered, it is a totally reasonable option for a generation writer to prepare some input for another generation writer that is to run at some later point within the remaining
part of the stage.

Since generator's work is to be based on FDOM, it almost always relies on compiled model readers to fetch the data. A generation writer typically supports a certain set of compiled model readers, and has
to be aware of the corresponding FDOM storage settings via a certain part of configuration.

Generation stage is controlled by <#ref M/lp-config.json/members/lp-generate#> entry of the configuration file.

Generation writer must be implemented in compliance with the corresponding interface: <#ref M/interfaces/generate/writer#>.

Logipard comes with some built-in generation writers: <#ref M/stages/generate-stage/builtin-writers#>

#LP }

#LP } <-#stages#>

#LP M/reference { <#./%title: Reference#>
The reference on the items and interfaces that a Logipard user may need to deal with at one point or another.

#LP M/interfaces {
API interfaces and extra configuration items for built-in plugins.
#LP } <-#interfaces#>

<#./%link #
	M/interfaces
	M/lpinput
	M/lpgwrite-example-program
	M/lpgread-interface
	M/LPSON
#>
#LP }
