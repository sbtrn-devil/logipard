#LP-include lp-module-inc.lp-txt

#LP M/readme { <#./%title: Getting started with Logipard#>

In this section we'll explain what Logipard is and how to approach it.

## Motivation

The existing annotation-based documentation generators often fall short in key areas:

1. **Limited Scope of Documentation**  
   Most tools generate documentation focused solely on code objects (e.g., classes, modules, functions). However, they lack support for higher-level documentation, such as:
   - Detached quickstart guides and common use cases.
   - Documenting in terms of domain-specific objects and workflows that may have no simple 1:1 mapping to code objects.
   - Embedded developer notes, task references, custom metadata, or other sort of non-standard information.

2. **Language-Specific Constraints**  
   These tools are typically tied to specific programming languages, making it difficult to document:
   - Higher-level or domain-specific objects (e.g., scripts, resources, utility tools).
   - Relationships between objects across different domains (e.g., host language and scripting system).
   Additionally, annotation placement is often restricted, limiting flexibility in organizing and structuring documentation sources.

3. **Rigid Output Formats**  
   Generated documentation is usually end-user-oriented and sealed, making it difficult to:
   - Link or cross-reference with other documentation artifacts.
   - Use machine-readable formats (e.g., XML, JSON) effectively, even if a tool is capable of generating them, as they often retain the same hardcoded rigid structure as human-readable outputs.

## How Logipard Addresses These Issues

Logipard introduces a novel approach to documentation generation, centered around two key concepts:

1. **Freeform Documentation Object Model (FDOM)**
   Logipard collects all documentation fragments into a single project-wide database called the **Freeform Documentation Object Model (FDOM)**. FDOM is designed to be:
   - **Flexible**: It imposes no restrictions on documentation structure or semantics of document items, allowing you to include software objects, user manual chapters, developer notes, or whatever else,
   or any mix of the above, and organize them into any structure you see appropriate.
   - **Language-Agnostic**: It supports documentation from multiple sources, regardless of the programming language or domain.
   - **Cross-Referencing Enabled**: FDOM provides a unified naming space, enabling seamless cross-referencing between different parts of the documentation (e. g., between a field in a table creation SQL
   and its backing objects in business logic code).

2. **Tool-Oriented Documentation Artifact**
   FDOM is a machine-readable, tool-oriented artifact rather than an end-user-oriented one. It serves as the primary documentation information source, which can be queried and sliced in various ways.
   End-user documentation (e.g., API references, user manuals) is generated by **generators** - sub-tools that read relevant slices from FDOM, organize them according to the target document's structure,
   and produce the final output.

## Key Benefits of Logipard

- **Unified Documentation Data Store**: FDOM consolidates all documentation fragments into a single, flexible model.
- **Language and Domain Independence**: Document code objects, scripts, workflows, and more, all in one place.
- **Enhanced Cross-Referencing**: Easily link related objects across different domains or documentation types.
- **Customizable Output**: Generate tailored documentation artifacts for different purposes (e.g., developer notes, end-user documentation).

Now let's get to know the flow...

#LP ./install { <#./%title: Installation#> <#./%order: 1#>
Install Node.js 13 or higher.

Then, install Logipard CLI either globally:
```
# from gitverse
npm install -g git+https://gitverse.ru/mikle33/logipard

# or: from github
# TODO

# or: from npm
# TODO
```
or locally into your current folder:
```
# from gitverse
npm install git+https://gitverse.ru/mikle33/logipard

# or: from github
# TODO

# or: from npm
# TODO
```


After global installation, the Logipard CLI can be run from anywhere:
```
lp-cli [cmd line options]
```

After local installation, the Logipard CLI can be run from the current folder:

_Linux_:
```
node_modules/.bin/lp-cli [cmd line options]
```

_Windows_:
```
node_modules\.bin\lp-cli [cmd line options]
```

Run lp-cli without options or with `-h` or `--help` for summary of the command line options (they are quite few, most of the work
is intended to be specified via configuration file(s)).

After installation you can go through <#ref readme/quickstart#> to get a grip on how things are done.

#LP }

#LP ./quickstart { <#./%title: A quickstart example#> <#./%order: 2#>
For example, you are going to write an innovative library to make a revolution in the programming world.

You have created a directory for the project to live in (let's refer to it as `<PROJECT_ROOT>`), possibly even created a `package.json`
in it (let's say it is a Node.js library).

Also you have already installed Logipard CLI as described in <#ref readme/install#> - we'll assume the CLI command is `lp-cli [options]`
(adjust it if you installed locally).

Create the main library codebase:

<small><u>Create file</u></small>: `<PROJECT_ROOT>/index.js`
```
module.exports.leftpad = function leftpad(str, len, padding = ' ') {
	str = str + '';
	if (str.length >= len) return str;
	padding = (padding = padding + '').length ? padding : ' ';
	while (padding.length + str.length < len) {
		padding = padding + padding;
	}
	return padding.substring(0, len - str.length) + str;
}
```

Now we can start documenting our stuff.

#LP ./doc-basics { <#./%title: Documenting basics#><#./%order: 2.1#>

The primary source for documentation is source code annotations. In our case, we can add some this way:

<small><u>Edit file</u></small>: `<PROJECT_ROOT>/index.js`
<#~~
```
//#LP functions/leftpad { <#./%title: leftpad(str, len[, padding])#>
// Pad a string from left to the given minimum length with whitespaces or a given padding string.
//#LP ./str %arg: String to be padded
//#LP ./len %arg: Number, minimum required length of the padded string (<#ref leftpad/str#>)
//#LP ./padding %arg: String, optional. If specified, this string or its portion will be used for the padding instead of spaces.
//
// The string is repeated as required if it is less than the length required for the padding, and its leftmost part of the required length is used.
module.exports.leftpad = function leftpad(str, len, padding = ' ') {
	... // almost everything within can be left as is so far

	//#LP ./%return: The padded string with minimum length of (<#ref leftpad/len#>)
	return padding.substring(0, len - str.length) + str;
}

//#LP }
```
~~#>

The annotations look mostly readable and probably almost self-descriptive (not counting some fancy syntax details, which we won't be getting into right now), but there is a bit more to it than meets the eye
and that should be mentioned.

First, a technical note: Logipard recognizes as annotations the contiguous sequences of single-line comments (`//` here), possibly with some code at beginning of the line, where first comment starts with `#LP` token,
and until the next line that does not end with single-line comment. Here, the `//` line after `./padding` is required to keep the `// The string is ...` comment included into the run.
On the other hand, the `// almost everything ...` comment line is separated from the run by non-comment ending line, so this comment is 'just a code comment' and is ignored.

Keep this in check to ensure you will have the related comments included, and unrelated comments not included.

Second, Logipard is entirely agnostic on the source code and any language entities. All that matters is the documentation model structure, and this structure
is entirely up to you to determine and to follow consistently.

For example, in our documentation we opted for the following items with the following names:

- `functions`: the item automatically introduced by fact we introduced its member sub-items, we'll consider it a container for the functions list
- `functions/leftpad`: the primary documentation item for our function, contains everything related to it (i. e. the following items)
- `functions/leftpad/%title` (comes from `./%title`): the item that contains human readable title for the main item
- `functions/leftpad/str`, `functions/leftpad/len`, `functions/leftpad/padding`: items documenting arguments of the function, note each of them is tagged with `%arg` model tag
- `functions/leftpad/%return`: the item that documents our function's returned value
- `%arg`: the model tag item with this name, introduced by the fact it was used

Note that any semantic meaning for the items (functions list container, function's main item, items for function's readable title and return value, the fact we tag the arguments specifically with `%arg`,
the fact that the documented entity is specifically a function) is also entirely conventional, as well as their names. From Logipard documentation model perspective, all of these are just generic items,
and at this point their interpretation in the way described above only exists in our mind.

<small>Convention in your own use cases may be different, but for purpose of our quickstart let's adhere to this one.</small>

Another point is that location of the annotations is not actually important - choose it for your convenience. Here we placed it near the documented function declaration, similar to how it is done for
conventional doc generators like Javadoc, TSDoc, Doxygen, etc. (And even here, we opted to put the `%return` fragment near the return statement rather
than bundled with parameters block - again, purely for example; we could as well place it more traditionally.) In general, however, you could place it anywhere in the source file,
or in a different file, or even place different sub-items across different locations. Probably it makes not much sense for things like function arguments and return value, but these may be not the only
items related to this function you may want to document under this node.

#LP } <-#doc-basics#>

#LP ./doc-good-style { <#./%title: Good style tips#><#./%order: 2.2#>

Although there are no inherent restrictions on choosing structure and naming items in the document model, there are a few points to take for keeping good style
and manageability.
- the short names for items that are supposed to be auxiliary data fields or to be used as tags should start from `%`. Fortunately, we have this already.
- the documentation items specific to your project/module/library should be placed under a single root item with a sufficiently unique name specific to this project (__project domain__).
This will help you to avoid name conflicts if you integrate several projects and to be able to merge their documentation easier.

Here, names we picked for our items are not the best choice. We'd better go with something like:

- `domain.our-unique.leftpad.for-nodejs/functions`
- `domain.our-unique.leftpad.for-nodejs/functions/leftpad`
- `domain.our-unique.leftpad.for-nodejs/functions/leftpad/%title`
- `domain.our-unique.leftpad.for-nodejs/functions/leftpad/str`
- `domain.our-unique.leftpad.for-nodejs/functions/leftpad/len`
- `domain.our-unique.leftpad.for-nodejs/functions/leftpad/padding`
- `domain.our-unique.leftpad.for-nodejs/functions/leftpad/%return`
- `%arg` (this can be left as is, for some reasons)

It is surely impractical to type the domain item prefix every time we may need it (even though we don't need it too often). For this purpose, it is better to define an alias. Let's do this:

<small><u>Edit file</u></small>: `<PROJECT_ROOT>/index.js`
<#~~
```
//#LP-alias M: domain.our-unique.leftpad.for-nodejs

// now instead of domain.our-unique.leftpad.for-nodejs/functions/... we can use M/functions

//#LP M/functions/leftpad { <#./%title: leftpad(str, len[, padding])#>
...
// ...the remaining part of the file can be left unchanged, since it uses relative names
```
~~#>

Furthermore, that `//#LP-alias M: domain.our-unique.leftpad.for-nodejs` will likely be the shared common part for all files that contain documentation
for our project, and possibly more shared prologue parts will occur eventually. To further reduce duplication, we can move this to separate file and
just include it everywhere we need...

<small><u>Create file</u></small>: `<PROJECT_ROOT>/leftpad-module-inc.lp-txt`
#LP~ex~
```
#LP-alias M: domain.our-unique.leftpad.for-nodejs
```
#LP~ex~
(Note a bit different structure for this file. As Logipard is language agnostic, even standalone text files purely consisting of Logipard annotations
are an option.)

<small><u>Edit file</u></small>: `<PROJECT_ROOT>/index.js`
<#~~
```
//#LP-include leftpad-module-inc.lp-txt

//#LP M/functions/leftpad { <#./%title: leftpad(str, len[, padding])#>
...
// ...the remaining part of the file still unchanged
```
~~#>

#LP } <-#doc-good-style#>

#LP ./prepare-html-template { <#./%title: Prepare HTML template file#> <#./%order: 2.3#>
In this quickstart we are making a HTML documentation, and first thing we will need for this is to prepare a HTML template file.

<small><u>Create file</u></small>: `<PROJECT_ROOT>/leftpad-doc-html.tpl.html`
<#~~
```
<html>
<head>
<style>
body {
	font-family: sans-serif;
}
code {
	font-family: monospace;
	background: lightgray;
	margin: 0;
	padding: 0;
}
pre {
	font-family: monospace;
	background: lightgray;
	margin: 0;
	padding: 0;
}
table, th, td { border: 1px solid; border-spacing: 0; border-collapse: collapse; }
table { margin: 0.5em }
CSS_TARGET
</style>
</head>
<body>
<div style="display: flex; flex-direction: column; height: 100%; overflow: hidden">

<div style="border-bottom: double 3px">
<center style="font-size: 200%">leftpad for node.js</center>
<center style="font-size: 75%">1.0.0</center>
</div>

<div style="padding: 0; margin: 0; overflow: clip; height: 0; flex-grow: 1">
HTML_TARGET
</div>

</div>
</body>
</html>
```
~~#>
This template is purely for example, and includes a bare minimum of items possible. Note the `CSS_TARGET` and `HTML_TARGET` placeholders.

#LP }

#LP ./prepare-lp-config { <#./%title: Prepare LP configuration file#> <#./%order: 2.4#>
Now, to proceed to something more substantial, we need to prepare Logipard configuration file. We'll not explain right now most of the magic happening here,
just keep in mind that it is where you reify your conventions on document model, and specify the other technical stuff.

<small><u>Create file</u></small>: `<PROJECT_ROOT>/lp-config.json`
<#~~
```
//#charset utf-8
// (That comment annotation above is taken into consideration, hopefully you will be saving this file in UTF-8)
// This doesn't quite look like a valid JSON (including the comments), but don't bother for now,
// just copy and paste everything as is.
{
	"+ config": {
	},

	"lp-extract": {
		"+ config": {
			// note that non-absolute paths are relative to project root (which is location of this config file)
			"+ excludeInFiles": ["node_modules/**"]
		},
		"items": [
			{
				// section for the primary codbase, in our case it is all the JS files
				"inFiles": ["**/*.js"], 
				"excludeInFiles": [],
				"outDir": "lp-extract.gen",
				"reader": "${LP_HOME}/lpxread-basic" $, // trailing $ is not a typo
				"lpxread-basic": {
					"srcType": "generic-c-like"
				}
			},
			{
				// remember the leftpad-module-inc.lp-txt? it falls under this section
				"inFiles": ["**/*-inc.lp-txt"],
				"excludeInFiles": [],
				"forLPInclude": true,
				"outDir": "lp-extract.gen/lp-includes",
				"reader": "${LP_HOME}/lpxread-basic" $,
				"lpxread-basic": {
					"srcType": "lp-text"
				}
			}
		]
	},

	"lp-compile": {
		"+ config": {
		},
		"items": [
			{
				"inRootDir": "lp-extract.gen",
				"lpIncLookupDirName": "lp-includes",
				"writer": "${LP_HOME}/lpcwrite-basic-json" $,
				"lpcwrite-basic-json": {
					// you may want to customize this for your project name
					"outFile": "lp-compile.gen/leftpad-doc-fdom.json"
				}
			}
		]
	},

	"lp-generate": {
		"+ config": {
		},
		"items": [
			{
				"inFile": "lp-compile.gen/leftpad-doc-fdom.json", // same as outFile in lp-compile section
				"writer": "${LP_HOME}/lpgwrite-example" $,
				"lpgwrite-example": {
					// very much magic here, just paste it with no hesitation
					"program": file("${LP_HOME}/lpgwrite-example-docprg.lpson" $, {
						"docprgPrologue": [ { "nameAlias": "M", "name": "domain.our-unique.leftpad.for-nodejs" } ],
						"docRootItems": {
							"query": [{ "with": "M/functions" }],
							"sort": { "byMember": "%order", "keyFormat": "ds-natural", "order": "asc" }
						},
						"LS_EXTENDS": "Extends (is a)",
						"LS_MEMBERS": "Members",
						"LS_NAME": "Name",
						"LS_DESCRIPTION": "Description",
						"LS_MEMBERS_FROM_EXTENTS": "Members from extents",
						"LS_ARGUMENTS": "Arguments",
						"LS_RETURNS": "Returns:",
						"LS_ERRORS": "Errors:",
						"LS_MEMBERS_DETAILED": "Members (detailed)",
						"LS_MEMBERS_FROM_EXTENTS_DETAILED": "Members from extents (detailed)",
						"LS_ARGUMENTS_DETAILED": "Arguments (detailed)",
						"LS_NOTES": "Notes",
						"LS_PROPERTIES": "Properties",
						"LS_PROPERTIES_FROM_EXTENTS": "Properties from extents",
						"LS_METHODS": "Methods",
						"LS_METHODS_FROM_EXTENTS": "Methods from extents"
					}),
					"renders": [
						{
							"docModel": "DocMain",
							"renderer": "${LP_HOME}/lpgwrite-example-render-html" $,
							"lpgwrite-example-render-html": {
								"outFile": "lp-generate.gen/leftpad-doc.html",
								"emitToc": true,
								"inTemplateFile": "leftpad-doc-html.tpl.html",
								"htmlPlaceholder": "HTML_TARGET",
								"cssPlaceholder": "CSS_TARGET",
								"localizedKeywords": {
									"SNAPBACK": "Snapback",
									"SNAPBACK_AND_SCROLL": "Snapback & Scroll",
									"ELEVATE": "Elevate",
									"RESET": "Reset",
									"ELEVATE_TO": "Elevate to...",
									"COPY_ITEM_NAME": "Copy this item's LP FDOM full name to clipboard:",
									"ITEM_UNFOLDED_ELSEWHERE": "Item unfolded elsewhere on page, click/tap to unfold here...",
									"MORE": "More... >>",
									"TABLE_OF_CONTENTS": "Table of contents"
								}
							}
						}
					]
				}
			}
		]
	}
}
```
~~#>

#LP } <-#prepare-lp-config#>

#LP ./run-lp-cli { <#./%title: Run LP pipeline#> <#./%order: 2.5#>
We are all set to generate our quickstart project's documentation page.

Assuming your current work directory is `<PROJECT_ROOT>` and your current user has write permissions in it, invoke the CLI:
```
lp-cli lp-config.json
```

You should see some output, which, in case of success, is like this:
```
=== Performing stage: EXTRACT ===
EXTRACT: 15.039ms
=== Performing stage: COMPILE ===
COMPILE: 18.592ms
=== Performing stage: GENERATE ===
Start render
lpgwrite-example-render-html: file lp-generate.gen/leftpad-doc.html created
GENERATE: 69.098ms
```

Several new directories should appear, including `lp-generate.gen`, which should contain `leftpad-doc.html` file. It is our documentation page, ready to view via browser.
Isn't it nice? An extra note: it is a completely self-contained HTML file, you can move it around alone with no fear to lose some dependencies, and it is static and indexation friendly when hosted on web.

Also take a look into folder `lp-compile.gen` and file `leftpad-doc-fdom.json` in it. It is your documentation model DB (in JSON form, for this instance).

Although it looks less impressive and hardly human readable, and is in fact an intermediate artifact you can disregard most of the time, it is actually the core item in
Logipard paradigm. This DB is assumed to hold all LP documentation fragments from across the project in the same single space. Then there can be multiple final documents,
made up of appropriate slices of this DB, but they all will share it as the data source.

Let's proceed with the quickstart and see how this can work in our case.

#LP } <-#run-lp-cli#>

#LP ./make-readme { <#./%title: Prepare README snippet#> <#./%order: 2.6#>

Now that we have our library code finalized, we would like to supply something like README file. And, ideally, have it both as standalone README.md and as a part of main HTML page.

Let's start by making a source file...

<small><u>Create file</u></small>: `<PROJECT_ROOT>/readme.lp-txt`
#LP~~
````
#charset utf-8
#LP-include leftpad-module-inc.lp-txt

#-LP note the syntax difference when we are using plain text-ish files
# by the way, fragments opened by #-LP are treated as non-annotation comments by Logipard
# and will not in make it into DB and documentation, they span until next #LP tag.

# So this paragraph is still a LP comment (the hashes are actually optional, but the visual style
# better be consistent). Also note that consistent indentation (same amount of same type of whitespaces
# at start of each interim line within the #LP scope) is handled gracefully.

#LP M/readme { <#./%title: leftpad: quickstart#>

	String left pad, revised and improved.

	#LP ./install { <#./%title: Install#> <#./%order: 1#>
		```
		$ npm install git+https://<whereismygit.com>/leftpad
		# TODO: actual location
		```
	#LP }

	#LP ./usage { <#./%title: Usage#> <#./%order: 2#>
		Use it this way:
		```
		const { leftpad } = require('./leftpad');

		leftpad('foo', 5);
		// '  foo'

		leftpad('foo', 2);
		// 'foo'

		leftpad('foo', 10, '+-=');
		// '+-=+-=+foo'
		```
	#LP }

	#-LP By the way, it is a good idea to add reference to the usage under the documented function hub...

	#LP M/functions/leftpad/usage { <#./%title: Usage#>
		See some usage examples under <#ref readme/usage#>.
	#LP }

	#-LP And also give the functions section some official stuffing...

	#LP M/functions: <#./%title: Functions reference#>
	Reference on the library functions.

	#-LP Be careful though of one caveat when using multi-line #LP...: syntax: its scope is terminated with next non-<#...#>'d #LP tag or #-LP comment
	# So lines after this comment are again in M/readme (and the comment itself, in turn, only ends with an #LP tag)

	#LP ./versions { <#./%title: Versions summary#> <#./%order: 3#>
		#LP ./1.0.0: Initial release version.

		#LP ./0.0.9: Pre-release version.

		Was not documented with LP, so it pretty sucked.
	#LP }

#LP }
````
#LP~~

Then let's add this...

<small><u>Edit file</u></small>: `<PROJECT_ROOT>/lp-config.json`
```
...
	"lp-extract": {
	... // under "items"...
		"items": [
			// add third item (to capture the new readme.lp-txt):
			...,
			{
				"inFiles": ["**/*.lp-txt"],
				"excludeInFiles": [],
				"outDir": "lp-extract.gen",
				"reader": "${LP_HOME}/lpxread-basic" $,
				"lpxread-basic": {
					"srcType": "lp-text"
				}
			}
		]
	},
...
	"lp-generate": {
	... // in the first (and so far the only) item under "items"...
		"items": [
			{
				"inFile": "lp-compile.gen/leftpad-doc-fdom.json",
				"writer": "${LP_HOME}/lpgwrite-example" $,
				"lpgwrite-example": {
... // leave most as is, except for....
						"docRootItems": {
							"query": [{ "with": ["M/readme", "M/functions"] }], // <-- change "query" member to this
							],
... // everything here remains as is
						},
... // here as well
			},
			// then, add this second item to "items":
			{
				"inFile": "lp-compile.gen/leftpad-doc-fdom.json", // note, still same as outFile in lp-compile section
				"writer": "${LP_HOME}/lpgwrite-example" $,
				"lpgwrite-example": {
					"program": file("${LP_HOME}/lpgwrite-example-docprg.lpson" $, {
						"docprgPrologue": [ { "nameAlias": "M", "name": "domain.our-unique.leftpad.for-nodejs" } ],
						"docRootItems": {
							"query": [{ "with": ["M/readme"] }],
							],
							"sort": { "byMember": "%order", "keyFormat": "natural", "order": "asc" }
						}
					}),
					"renders": [
						{
							"docModel": "DocMain",
							"renderer": "${LP_HOME}/lpgwrite-example-render-md" $,
							"lpgwrite-example-render-md": {
								"outFile": "lp-generate.gen/leftpad-README.md",
								"emitToc": true,
								"addSourceRef": false,
								"header": "# leftpad #\n\n---",
							}
						}
					]
				}
			}
		// everything else remains as is
		}
...

```

Run LP pipeline again:
```
lp-cli lp-config.json
```

Now, check again `lp-generate.gen`: you should see new file `leftpad-README.md` (check it with some MD viewer you have at hand), and the file `leftpad-doc.html` has updated - 
now it includes the same information as in readme, while still featuring the functions reference, and you can see some other improvements you might have guessed from the
readme source.

#LP } <-#make-readme#>

#LP ./conclusion { <#./%title: Conclusion#> <#./%order: 2.7#>

This is how the basic documentation tasks are done with Logipard, and possibly more than sufficient for everyday needs. But there are much more things you can do within its framework
and with the documentation model, possibly not even limited to simple documenting. In order to see more capabilities, and to get better understanding of what we've done in the quickstart,
check the main documentation.

Also, as an example of a more complex project documented with Logipard, feel free to explore Logipard code itself. All of the documentation sources are intentionally retained in its package.

#LP } <-#conclusion#>

#LP } <-#quickstart#>

#LP } readme
